# Algorithm-Swift

##    **按照算法方法分类**

[北美算法面试的题目分类，按类型和规律刷题，事半功倍](https://zhuanlan.zhihu.com/p/89392459)

[动态规划及面试，学完这一篇，你就入门了：Dynamic Programming, 动态规划，经典题目](https://zhuanlan.zhihu.com/p/89391817)

>   **一般对所要求解的问题的时间复杂度要求比较高的，可以优先考虑如下几种算法。**
>
>   **①分治法**
>
>   **②递归法**
>
>   **③贪心算法**
>
>   **④动态规划算法**

### 动态规划 DP

[DP算法](https://www.cnblogs.com/yinyiyu/p/6726185.html)

> [动态规划(DP)的整理-Python描述](https://blog.csdn.net/MrLevo520/article/details/75676160)
>
> > 解决问题
> >
> > 1. **背包问题** 
> >
> > - **主问题的答案 包含了 可分解的子问题答案 （也就是说，问题可以被递归的思想求解**）
> > - **递归求解时， 很多子问题的答案会被多次重复利用**
> >
> > ​     **动态规划的本质思想就是递归， 但如果直接应用递归方法， 子问题的答案会被重复计算产生浪费， 同时递归更加耗费栈内存， 所以通常用一个二维矩阵（表格）来表示不同子问题的答案， 以实现更加高效的求解。**



* [漫画：什么是动态规划？](https://blog.csdn.net/moakun/article/details/79928067)

  [什么是动态规划？动态规划的意义是什么？](https://www.zhihu.com/question/23995189?utm_source=wechat_session&utm_medium=social&utm_oi=43526393954304)

  [322-零钱兑换](https://zhuanlan.zhihu.com/p/61277271)

  [[动态规划入门题之国王和金矿(0-1背包问题)](https://www.cnblogs.com/hczd123/p/7412950.html)](https://www.cnblogs.com/hczd123/p/7412950.html)

*  递归不是动态规划，不能混淆，二者有相通的地方，**递归是自顶向下，动归是自底向上**。动归是递归综合备忘录算法以后的反向思维形式。

 

*   动态规划的设计，其实就是利用**最优子结构和重叠子问题性质对穷举法进行优化**，通过将中间结果保存在数组中，实现**用空间来换取时间交换**，实现程序的快速运行。（动态规划求解时，一般都会转化为网格进行求解，而且因为是空间换时间（避免了子问题的重复计算），因此一般迭代求解）



* 动态规划杀手锏

  **1）建模：**

  * 最优子结构  F(10) = F(9) + F(8 )
  * 状态转移方程   F(n) = F(n-1) + f(n-2)
  * 边界   F(1)   F(2)

  

  **2）实现：**

  递归法

  备忘录法（从上到下，非全二叉树，hash保存！）

  自底而上（迭代实现）

```swift
'最后总结一下DP算法的思路:

'先自顶向下找到规律'，再通过状态转移方程描述这个规律，最后使用'自底向上简化时间复杂度。

核心: '最优子结构、边界条件、状态转移方程 

解题步骤: 1,建立数学模型 2,写代码求解问题 
  '  如何建模?
       先写出所求问题的最优子结构,进而分析出边界和状态转移方程,数学模型即这2者的组合
       对于2输入维度动态规划 画表格帮助分析 行列分别代表1个输入维度

   ' 如何求解?
      建好模后,根据方程组'写出自底向上的动态规划代码',一维输入就是1个for循环,二维输入就是2个for循环,如果方程组比较抽象,
      可以画表格帮助分析
```



### 贪心算法

* 实现思路：

  1. 从问题的某个初始解出发。
  2. 采用**循环语句**，当可以向求解目标前进一步时，就根据局部最优策略，得到一个部分解，缩小问题的范围或规模。
  3. 将所有部分解综合起来，得到问题的最终解。

  

### 递归

* 递归算法的两个重要特征，比如：

  1. 有终止的条件，不然就成了死循环了
  2. 不停调用自身

* 写出递归函数也就是要处理好递归的3个主要的点: 

  ​      a)出口条件，即递归“什么时候结束”，这个通常在递归函数的开始就写好;    1

  ​      b) 如何由"情况 n" 变化到"情况 n+1", 也就是非出口情况，也就是一般情况——"正在"递归中的情况；       

  ​      c) 初始条件，也就是这个递归调用以什么样的初始条件开始    2 

  ​    可以说，上述a,b,c三个条件组成了我们的递归函数；解决好上述3点，也就很容易地写出一个递归函数；剩下的就是去学习学习“数学归纳法”，请自己google之；不许要你称为归纳法专家，但只需要认证体会它的思路，对于你理解和创造递归函数有很大帮助



* 排序和查找是面试时考察算法的重点，**排序中应该重点掌握二分查找、归并排序和快速排序。** 有很多算法都可以用递归和循坏两种不同的方式实现，**通常基于递归的实现方法会比较简洁，但性能不如基于循环的实现方法。**

  常用的排序有：冒泡排序、选择排序、插入排序、堆排序、归并排序、快速排序、希尔排序、计数排序、桶排序、基数排序等。

  七大查找算法：顺序查找、二分查找、插值查找、斐波那契查找、树表查找、分块查找、哈希查找。

  **[递归由于是函数调用自身](http://www.10tiao.com/html/224/201512/425829999/1.html)，**而函数调用是有时间和空间的消耗的：**每一次函数调用，都需要在内存栈中分配空间以保存参数、返回地址及临时变量，而且往栈里压入数据和弹出数据都需要时间。另外，递归中有可能很多计算都是重复的，从而对性能带来很大的负面影响。除了效率之外，还有可能使调用栈溢出，前面分析中提到需要为每一次函数调用在内存栈中分配空间，而每个进程的栈的容量是有限的。当递归调用的层级太多时，就会超出栈的容量，从而导致调用栈溢出。**

  在使用算法的时候，时时刻刻需要考虑其时间复杂度与空间复杂度，特别是在软件层面开发时，往往对时间复杂度的要求更高

  

### 滑动窗口 <3个指针>

* 滑动窗口:是指的是数组/字符串问题的常用抽象概念.窗口通常在数组/字符串中由开始和结束的索引定义的一系列元素的集合.即可[`i,j)(左闭,右开)`.而滑动窗口是可以将2个边界向某一个方向"滑动"的窗口.例如,我们将`[i,j)`向右滑动1个元素,则它将变成`[i+1,j+1)(左闭,右开)`;

  

### DFS / BFS 

###     

### 备忘录法



### 双指针



### 快慢指针

###  

### 回溯算法



## **按照数据结构分类**

### 数组

### 链表

### 二叉树

### 排序

